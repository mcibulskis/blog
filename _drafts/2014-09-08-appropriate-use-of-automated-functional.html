---
layout: post
title: Appropriate Use of Automated Functional Tests
date: '2014-09-08T19:49:00.000-07:00'
author: Michael Cibulskis
tags:
- Test Driven Development
- Agile
modified_time: '2014-09-08T19:49:25.662-07:00'
blogger_id: tag:blogger.com,1999:blog-4949339273493077325.post-6547857162528012028
blogger_orig_url: http://www.noackexpected.com/2014/09/appropriate-use-of-automated-functional.html
---

<div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;">Recently, Uncle Bob posted <a href="http://blog.cleancoder.com/uncle-bob/2014/09/03/TestTime.html" target="_blank">(here)</a>&nbsp;about about the amount of time it takes for your tests to run and why developers need fast tests. &nbsp;It spurred me to write about my opinions of the way I've been seeing automated functional tests used (abused) at different clients.</span></span></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;"><br /></span></span></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;">Automated functional tests have their place, but it should not be to cover every last piece of functionality. &nbsp;They should cover the following:</span></span></div><div><br /><ol><li style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black; color: white;">Your most highly trafficked paths through your application. &nbsp;These are paths that 95% of your users interact with, and there are usually extremely few of these. &nbsp;For an e-commerce site, I would expect fewer than 10.</span></li><ul><li><span style="background-color: black; color: white; font-family: arial, sans-serif; font-size: 13px;">This is one point where I don't agree with Uncle Bob, because I think it is worthwhile to have the most heavily used paths actively regression tested prior to every deployment. &nbsp;I believe that he would argue that they are redundant given your unit and integration test coverage (he's right) and therefore unnecessary. &nbsp;But in many existing legacy code bases, the unit and integration tests do not provide sufficient coverage, so a sanity check of these paths is useful to have.</span></li></ul><li><span style="background-color: black; color: white; font-family: arial, sans-serif; font-size: 13px;">Basic end-to-end integration testing of the entire application stack to ensure that everything is still communicating as expected. &nbsp;There will usually only be a handful of these tests, going through the different components. &nbsp;Most of the time this will test just basic connectivity and maybe a couple basic operations.</span></li><li><span style="background-color: black; color: white; font-family: arial, sans-serif; font-size: 13px;">Situations that are difficult to adequately cover with unit and integration tests. &nbsp;These situations tend to be quite rare, but occur more frequently with legacy code bases or code bases with a great deal of technical debt that needs to be paid off. &nbsp;As the code base is improved, most of these tests should be able to be retired.</span></li><li><span style="background-color: black; color: white; font-family: arial, sans-serif; font-size: 13px;">Defects that are discovered in production and are able to be reproduced on demand. &nbsp;These provide confirmation that the defect was fixed. &nbsp;As the fix is implemented, appropriate unit and integration test coverage should also be added, so those faster tests will fail if the defect were to recur. &nbsp;For less critical defects, the functional tests can be retired after a time, when everyone is confident with the fix in production. &nbsp;For defects that occurred along the 95% of traffic paths, I would recommend keeping those tests indefinitely, because the business impact of those defects was likely quite large.</span></li></ol></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;">For some existing code bases, one of the challenges is the embedding of business logic into the UI layer, where it cannot be effectively unit tested. &nbsp;That leaves functional tests as the only way to test it. &nbsp;That doesn't make functional tests the answer to the problem, however. &nbsp;It makes them a bandage that is covering the underlying problem.</span></span></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;"><br /></span></span></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;">If your eventual strategy is to have a common set of e-commerce services (e.g. RESTful services) that can serve multiple different front end UIs (native mobile in addition to browsers), then continuing to embed business logic into the UI layer means that business logic will need to be replicated in each UI. &nbsp;Shifting the logic out of the UI into services that can be very easily unit tested would address not only future business value, making it easier to add new user interfaces, but also testability and test coverage.</span></span></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;"><br /></span></span></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;"><b><i>I know that my views on functional testing differ greatly from what some people espouse</i></b>. &nbsp;There are many people who would argue that every piece of functionality should have a corresponding functional test. &nbsp;That gives you business-level coverage of all the features as experienced by the end-user. &nbsp;I used to belong to that camp, but left it for the following reasons:</span></span></div><div><br /><ol><li style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black; color: white;">They simply take too long to execute to be useful for red-green-refactor cycles on a story. &nbsp;Although devs may start out with it as part of their red-green-refactor cycle, you will eventually have devs running the functional test for their story at the start (red) and end of their story (green), but nowhere in-between. &nbsp;They aren't going to want to wait minutes each time to spin up the server, start up the browser, and then run the test, especially when they "know it will fail because they aren't done with the story."</span></li><li><span style="background-color: black; color: white; font-family: arial, sans-serif; font-size: 13px;">They become redundant as the devs are working on the story, based on the unit and integration tests added for the story. &nbsp;You now have extra tests that you need to maintain in order to test something that is already being tested.</span></li><li><span style="background-color: black; color: white; font-family: arial, sans-serif; font-size: 13px;">They tend to run in environments that are unlikely to be as stable or reliable as your production environment, and are more sensitive to infrastructure issues than unit or integration tests. &nbsp;If it goes through 4 independent application layers (e.g. DB, servlets, internal 3rd party API, and external 3rd party API), the likelihood that the test will fail simply because of an infrastructure failure is the product of all of their likelihoods of being up (functioning as expected, no development defects in its deployment that affect the test in question, etc). &nbsp;For example, if the DB has a 99% likelihood of being up, the servlets have a 99% likelihood of being up, the internal 3rd party API has a 95% likelihood of being up, and the external 3rd party API has a 90% likelihood of being up, then the chance of any single test failing due to an infrastructure failure of any of those pieces is: 1 - (0.99 * 0.99 * 0.95 * 0.90) = 1 - 0.837 = 0.162 = 16.2%. &nbsp;That is a high rate of false negatives for that test, even though each looks like it has a high likelihood of being up for a non-production environment. &nbsp;Given that the infrastructure issues will likely affect all or a large number of your functional tests, then that effectively makes that entire run so noise-filled as to be almost worthless. &nbsp;If you split your application into micro services that communicate with each other and are all under active development, depending upon the deployment policies in your test environments, it can exacerbate the problem. (This was experienced at one client, where services had been structured in a pipeline, and the team developing the services at the end of the pipeline could very rarely run end-to-end tests because of breakages within services earlier in the pipeline, even though the likelihood of any given service in the pipeline being up reasonably high.)</span></li><li><span style="background-color: black; color: white; font-family: arial, sans-serif; font-size: 13px;">Even if they are relegated solely to regression testing prior to each release and their execution is divided over multiple servers, it could still take the better part of a day to complete. &nbsp;If we have any infrastructure failures with any integration points (#3), that makes the entire run almost worthless. &nbsp;Given that it takes hours to run the suite, running it over and over to get a clean run will quickly become a chore.</span></li><li><span style="background-color: black; color: white; font-family: arial, sans-serif; font-size: 13px;">If you keep the functional suite small, rerunning after an integration point infrastructure failure is not as big of a deal.</span></li></ol></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;">There are times when a larger functional suite might make sense. For example, if you were able to effectively test platform differences and your application had a lot of special handling across platforms. However, I think good unit and integration testing with few (but well-selected) functional tests would best serve most application's development and automated testing needs.</span></span></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;"><br /></span></span></div><div style="font-family: arial, sans-serif; font-size: 13px;"><span style="background-color: black;"><span style="color: white;">Keep in mind that you actually develop and maintain two separate applications for every project. &nbsp;One is the application for the business that has all of their desired functionality. &nbsp;The other is your tests, which facilitate changes and additions to the business' application in a safe and expeditious manner. &nbsp;If you fail to treat your tests as a valuable internal application that parallels the business' application, they are just as susceptible to code rot as the business' application, greatly reducing their value.</span></span></div>