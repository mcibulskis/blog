---
layout: post
title: TDD vs. Non-TDD Experiment
date: '2012-08-24T20:24:00.000-07:00'
author: Michael Cibulskis
tags:
- Test Driven Development
- Agile
- Pair Programming
- Craftsmanship
modified_time: '2013-05-10T21:22:13.902-07:00'
thumbnail: http://2.bp.blogspot.com/-MxkJgwmY1kI/UY2-lBDOoiI/AAAAAAAAAcg/59hVlKS2i5g/s72-c/TDDvsNonTDDGraph.jpg
blogger_id: tag:blogger.com,1999:blog-4949339273493077325.post-514371612900529398
blogger_orig_url: http://www.noackexpected.com/2012/08/tdd-vs-non-tdd-experiment.html
---

<h4>The Experiment</h4>I was fortunate enough today to take part in a very small (but extremely interesting) experiment (run by and performed using developers who have been using TDD for some time) that attempted to compare the quality of code, speed of development, and quality of the solution between three different "teams":<br /><br /><ul><li>Pair TDD (2 developers)</li><li>Pair Non-TDD (2 developers)</li><li>Single Non-TDD (1 developer)</li></ul><div>One additional person was part of the experiment, who played the role of the facilitator (Product Owner). &nbsp;The facilitator knew the entire exercise to be performed beforehand and was familiar with various solutions to it.</div><div><br /></div><div>The exercise was a customized version of the FizzBuzz kata, which included the base kata as the first few stories, followed by some twists designed to cause difficulties for typical solutions to the kata. &nbsp;The exercise was broken up into 12 separate stories (task cards describing a new, desired functionality).</div><div><br /></div><div>The stories were provided one-by-one, so that a team only ever knew the story that they were currently working on and had no advance knowledge of any upcoming stories (and were thus unable to pre-design for unknown new business requirements as if they were known). &nbsp;For example, if Team A was working on story 1, Team B was working on story 2, and Team C was working on story 1, only Team B knew what story 2 was. &nbsp;Neither Team A nor Team C received any knowledge of what story 2 contained until they finished story 1.</div><div><br /></div><div>The teams were allowed to work at their own pace, allowing some teams to be several stories ahead of other teams. &nbsp;Times at which stories were completed were captured for each team, allowing a graph to be created at the end of the experiment to aid with visualizing the relative progress and speed of the different teams.</div><div><br /></div><div>Code coverage and code quality were not directly measured during the experiment, but each team maintained and committed to a local git repository, capturing snapshots of their code at the completion of each of their stories.<br /><br />(5/10/2013) Unfortunately, the git repos used by the teams could not be recovered, but the final source code generated by the teams was successfully recovered. &nbsp;The source code for all the teams is available at&nbsp;<a href="https://github.com/mcibulskis/TDD-vs-NonTDD-Experiment-20120824">Github (TDD-vs-NonTDD-Experiment-20120824)</a><br /><br /><h4>Story Cards</h4></div>The story cards for this highly customized version of FizzBuzz were created by DJ Daugherty, who also served as the facilitator for the experiment.<br /><br /><ol><li>Generate a list of numbers between 1 and 100 inclusive&nbsp;</li><li>For each number in the list, if the number is a multiple of 3, replace it with the word "Fizz"&nbsp;</li><li>For each number in the list, if the number is a multiple of 5 (but not a multiple of 3), replace it with the word "Buzz"&nbsp;</li><li>For each number in the list, if the number contains a 3 (but has not already been replaced by "Fizz" or "Buzz"), replace it with the word "Fizz"&nbsp;</li><li>For each number in the list, if the number contains a 5 (but has not already been replaced by "Fizz" or "Buzz"), replace it with the word "Buzz"&nbsp;</li><li>For each number in the list, if the number is a multiple of both 3 and 5, instead of replacing it with the word "Fizz", replace it with the word "FizzBuzz"&nbsp;</li><li>Change the generation of the list of numbers to be 0 to 100 inclusive.  If the number is 0, replace it with the word "Zero"&nbsp;</li><li>Print the list (with all substitutions) forward, backward, and then forward again&nbsp;</li><li>Repeat 8, but follow it with another set of forward, backward, and forward, except using -100 to 0 as the set of numbers&nbsp;</li><li>Given the following custom ranges of numbers (note that this can either be printed to console or covered in a unit test), process them through the FizzBuzz replacement logic:&nbsp;</li><ul><li>2, 5, 7, 9, 12, 15&nbsp;</li><li>-3, -2, 0, 7, 9, 11&nbsp;</li><li>0&nbsp;</li></ul><li>Given a custom range of numbers (again, this can be covered in just a unit test or printed to console), process it through the FizzBuzz replacement logic:&nbsp;</li><ul><li>-33.33&nbsp;</li></ul><li>Given a string that contains FizzBuzz replacements for the range of values from 4 to 63 inclusive, "undo" the FizzBuzz logic to generate a candidate list of numbers.  All occurrences of "Fizz" should be replaced by all the numbers in the range that would have been "Fizz", all occurrences of "Buzz" should be replaced by all the numbers in the range that would have been "Buzz", and all occurrences of "FizzBuzz" should be replaced by all the numbers in the range that would have been "FizzBuzz".  For example:&nbsp;</li><ul><li>1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz =&gt; 1, 2, [3, 6, 9], 4, [5, 10], [3, 6, 9], 7, 8, [3, 6, 9], [5, 10]</li></ul></ol><div><ol><ul></ul></ol></div><h4>Story Completion Times: Comparison Across Teams</h4><div>During the experiment, the facilitator kept track of when each team started and completed each of the stories. The following image is a photo that was taken of the graph produced from the data during the exercise. &nbsp;The Y-axis is the story number. &nbsp;The X-axis is the time of day. &nbsp;The large "Break" bar in the middle of the day is when we stopped for lunch. &nbsp;Not all teams completed all of the stories, which is why some of the lines end early.</div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-MxkJgwmY1kI/UY2-lBDOoiI/AAAAAAAAAcg/59hVlKS2i5g/s1600/TDDvsNonTDDGraph.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="240" src="http://2.bp.blogspot.com/-MxkJgwmY1kI/UY2-lBDOoiI/AAAAAAAAAcg/59hVlKS2i5g/s320/TDDvsNonTDDGraph.jpg" width="320" /></a></div><div><br /></div><h4>Conclusions</h4><div>To add to the completeness of this post, <b><i>the following were the conclusions that were originally drawn from this experiment as part of the exercise</i></b>.</div><ul><li>Pair TDD is not necessarily the fastest to start â€“ more initial overhead.  However, the initial overhead quickly begins to pay off as additional complexity is added.&nbsp;</li><li>One might believe that Single Non-TDD would be the fastest, but it was quickly not the case.&nbsp;</li><li>Pairing (even without TDD) showed benefits early on, as the Single Non-TDD team had nobody to bounce ideas off of.&nbsp;</li><li>This problem was not very complex.  Even so, TDD showed some benefits fairly quickly, allowing them to surpass the other teams by the end of the experiment.  We believe this was largely due to the code coverage allowing for ease of refactoring, which the later stories required.&nbsp;</li><li>The communication process involved in pairing can allow for more elegant and robust solutions.&nbsp;</li><li>The teams that were used to doing TDD that were put into the situation where they had to use Non-TDD solutions felt "helpless" and were sometimes in situations where they felt like they had no efficient way of finding the underlying problem that was plaguing them.&nbsp;</li><li>The gap between the TDD and Non-TDD teams would have been widened if regression testing had been required for sign-off.</li></ul><h4>Criticisms</h4><div>While I believe that such an experiment is valuable and believe that the data we gathered in the experiment is interesting, I do not feel it is as useful, telling, or convincing as it could have been.</div><br />The outcome was pretty much as we expected it to be: &nbsp;the Pair TDD team was a little slower off the starting blocks (due to the extra overhead of setting up test cases for the relatively trivial stories early on), but ended up finishing all the tasks of the exercise before the other two teams. &nbsp;Their code quality was significantly higher, as was their test coverage.<br /><br />The biggest issue that I have with the outcome of the experiment (which I brought up during the retrospective, but which I felt was largely viewed as unimportant by the others), is that the code quality of the Pair Non-TDD and Single Non-TDD teams was so abysmal that it was almost unrealistically so. &nbsp;I cannot remember a time (before I started doing TDD) when code of that quality would have ever been allowed anywhere near a production system. &nbsp;Developers who would have attempted to commit such code would have been flogged and put on display for public humiliation. &nbsp;(Okay, not really that poorly treated, but they would have received a good talking to and probably some coaching to ensure that their code quality improved significantly.)<br /><br />Moreover, the only team that had any test coverage at all was the Pair TDD team, which is also entirely unrealistic. &nbsp;There should have been some "test after" unit tests created by both of the Non-TDD teams, which would have also helped their velocity by contributing to their ability to more easily refactor their code to include new functionality.<br /><br />What that means to me is that any comparisons that we make about code quality as a result of the experiment is entirely unrealistic. &nbsp;Because the code quality was unrealistic for those two teams, that then cascades and throws doubt upon all the other results. &nbsp;Would the Pair TDD team really have finished first if the code quality of the Non-TDD teams hadn't been so abysmal that it so adversely affected their velocity?<br /><br />So, simply because the code quality was unrealistically poor for the two Non-TDD teams, it ends up casting doubt upon the results of the entire experiment and most likely would prove entirely unconvincing to anyone who was looking to the experiment to be convinced that TDD actually does help improve code quality and speed of delivery.<br /><br />Even worse, the outcome of the experiment was effectively guaranteed to match what we wanted it to be.<br /><br /><h4>Improving the Experiment</h4>Several things can be done to improve the quality of the experiment:<br /><br /><ul><li>Include a "Single TDD" team type that consists of a single developer using TDD practices.</li><li>Have multiple teams of each type, preferably 3-4 teams of each type, for a total of 12-16 teams (about 18-24 developers). &nbsp;This will provide for a much larger set of data points, making it possible to have much more confidence in the conclusions drawn from the collected data.</li><li>Use a more complex problem for the experiment. &nbsp;The customized version of the FizzBuzz kata used was significantly more complex than the traditional FizzBuzz, but was still relatively simple. &nbsp;At the same time, this needs to be a problem that the teams can realistically complete in less than a day, in order to leave adequate time for the introduction, breaks, and the closing retrospective.</li><li>Most importantly, make sure to have developers who wholeheartedly believe in the approach of the team that they are on and actively practice that approach in their everyday job. &nbsp;In order to obtain realistic code quality for all teams, this is extremely important. &nbsp;Having people who do not regularly practice the type of coding approach of the team of which they are a part makes for a lot of guessing as to what someone who does practice that type of coding would do in such a situation, instead of drawing upon actual experience. &nbsp;In the end, all that guessing will only lead to code that is less representative of the actual code that would have been produced by an actual practitioner of that approach.</li><li>Have more realistic "sign-off"/acceptance requirements for when a task is deemed "complete". &nbsp;For example, requiring an actual (quick) code review, some amount of regression testing to ensure past functionality has not been compromised, etc. &nbsp;Note that this, in conjunction with the massively increased number of teams, will mean that additional people will be needed beyond the facilitator (Product Owner) to help with the sign-off requirements, as the facilitator will quickly become a bottleneck.</li></ul><h4>Final Words</h4><div>Despite all of my criticism, this was a valuable experiment, even if its greatest value was as an experiment about how to potentially better run this experiment in the future.</div><div><br /><i>Edits:</i><br /><span style="font-size: x-small;">8/24/2012 - Original post</span><br /><span style="font-size: x-small;">5/10/2013 - Included more details about the experiment, image of the graph showing team progress through the stories, conclusions that were initially drawn from the experiment, and added a link to the final source code produced by each team.</span></div>